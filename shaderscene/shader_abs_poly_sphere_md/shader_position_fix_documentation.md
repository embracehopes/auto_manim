# 球面多面体 Shader 位置依赖问题详细分析与修复方案

## 问题分析

### 问题现象
`SphericalPolyhedraSphere` 类创建的球体在移动位置后，其表面的 shader 效果会发生改变，导致多面体图案相对于球体的位置发生偏移或变形。

### 问题根源
通过分析 `spherical_polyhedra/vert.glsl` 文件，发现问题出现在第 40 行：

```glsl
// 传递归一化的球面位置给片段着色器
v_position = normalize(point);
```

这里的 `point` 是世界坐标系中的顶点位置。当球体移动时：
1. `point` 包含了球体的世界坐标位置偏移
2. `normalize(point)` 得到的是相对于世界原点的归一化向量
3. 片段着色器使用这个向量进行纹理计算，导致效果随位置变化

### 技术细节

#### 当前代码流程：
1. **顶点着色器**：`v_position = normalize(point)` - 使用世界坐标
2. **片段着色器**：`vec3 rd = normalize(v_position)` - 基于世界坐标计算
3. **结果**：shader 效果依赖于球体在世界坐标系中的绝对位置

#### 期望的正确流程：
1. **顶点着色器**：计算相对于球体中心的本地坐标
2. **片段着色器**：基于本地坐标进行纹理计算
3. **结果**：shader 效果只依赖于球体的几何形状，不受位置影响

## 修复方案

### 方案概述
创建位置无关的 shader 系统，通过以下步骤实现：

1. **修改顶点着色器**：传递球体的中心位置作为 uniform 变量
2. **计算本地坐标**：在顶点着色器中计算相对于球体中心的本地位置
3. **更新片段着色器**：使用本地坐标进行所有纹理计算
4. **自动更新机制**：在球体移动时自动更新中心位置

### 核心原理

#### 坐标变换公式：
```
local_position = world_position - sphere_center
normalized_local = normalize(local_position)
```

#### Shader 计算：
- **错误方式**：`normalize(world_position)` - 依赖世界坐标
- **正确方式**：`normalize(world_position - sphere_center)` - 使用本地坐标

## 实现细节

### 1. 新增 Uniform 变量
```glsl
uniform vec3 sphere_center;  // 球体中心位置
```

### 2. 顶点着色器修改
```glsl
// 计算相对于球体中心的本地位置
vec3 local_position = point - sphere_center;
v_position = normalize(local_position);
```

### 3. Python 类修改
- 添加 `sphere_center` uniform 的管理
- 在 `move_to()` 和 `shift()` 方法中自动更新中心位置
- 确保初始化时正确设置中心位置

## 性能影响

### 计算开销：
- **额外开销**：每个顶点一次向量减法操作
- **性能影响**：可忽略不计（现代GPU可轻松处理）
- **内存开销**：增加一个 vec3 uniform 变量（12字节）

### 优化考虑：
- Uniform 变量只在位置改变时更新，避免不必要的计算
- 本地坐标计算在顶点着色器中进行，充分利用GPU并行性

## 兼容性说明

### 向后兼容：
- 现有的 API 保持不变
- 所有参数和方法调用方式保持一致
- 只有内部 shader 计算逻辑改变

### 扩展性：
- 修复方案适用于所有基于球面的 shader 效果
- 可以扩展到其他几何体（立方体、圆柱体等）
- 为未来的 shader 效果提供了标准的位置无关框架

## 测试验证

### 测试场景：
1. **静态测试**：多个球体在不同位置，验证效果一致性
2. **动态测试**：球体移动过程中，验证效果稳定性
3. **对比测试**：修复前后效果的直观对比
4. **性能测试**：验证修复对渲染性能的影响

### 验证标准：
- ✅ 球体移动时，多面体图案保持相对位置不变
- ✅ 不同位置的球体显示相同的图案
- ✅ 动画效果（旋转、切换）正常工作
- ✅ 性能无明显下降

## 使用建议

### 最佳实践：
1. 使用修复后的 `FixedSphericalPolyhedraSphere` 类
2. 避免直接修改 uniform 变量，使用提供的方法
3. 大量球体场景下，考虑使用实例化渲染

### 注意事项：
- 修复仅影响 shader 计算，不改变球体的物理位置
- 确保在球体创建后再设置位置，以保证正确的初始化
- 对于动画场景，建议使用提供的移动方法而非直接修改坐标

## 总结

通过将 shader 计算从世界坐标系转换为本地坐标系，成功解决了球面多面体效果随位置变化的问题。这个修复方案：

- 🎯 **完全解决**了位置依赖问题
- 🔄 **保持兼容**性，无需修改现有代码
- ⚡ **性能优秀**，几乎无额外开销
- 🧩 **易于扩展**，可应用于其他 shader 效果

该解决方案为 Manim shader 系统提供了一个标准的位置无关实现模式，可以作为未来类似问题的参考和模板。
